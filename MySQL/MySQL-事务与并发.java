-----------------------
MySQL-事务				|
-----------------------
	# 讲事务这东西,都是拿银行转账来说事儿.
	# 事务跟存储引擎相关.有些引擎是不支持事务的

-----------------------
MySQL-CMD操作事务		|
-----------------------
	# 开启事务
		START TRANSACTION;
		# 开启了之后,就会把操作记录到事务日志
		# 还有一种方式设置.
			set autocommit=1;
			* 该方式,直接针对'当前连接'进行设置,以后的每次增删改操作,默认都是需要手动提交
			* 值也可以是:ON	 也是代表开启

	# 执行操作
		update...
		delete...
		insert...

	# 提交/回滚事务
		COMMIT;	
		ROLLBACK;

-----------------------
MySQL-事务回滚点		|
-----------------------
	# 其实我理解就是传说中的保存点.
	# 在某一个成功的操作完成之后,后续的操作有可能成功.有可能失败.
	# 在当前的位置,设置一个保存点,让后面的失败操作,返回到该位置
	# savepint [回滚点名字];
	# rolback [回滚点名字];
	# 往往是在事务操作比较多的时候,会用到
	# 操作步骤
		1,开启事务
			... 逻辑操作
			... 设置回滚点1
			... 设置回滚点2
			...
		2,回滚到指定的点
			... 继续逻辑操作
		3,提交/commit
			...
	
	# 事务一旦回滚,就会清空事务日志.设置了点之后,就仅仅清空点之后的事务日志

-----------------------
MySQL-事务原理			|
-----------------------	
	# 事务开启之后,所有的操作都会临时保存到事务日志中
	# 而事务日志只有在得到commit命令,才会同步到数据表,其他的任何情况都会清空

-----------------------
自动事务				|
-----------------------
	# MySql中默认都是自动的事务处理,用户的每个操作.都会自己开启,提交事务
	# 系统通过: autocommit 变量俩进行控制
	# show variables like 'autocommit';
		* ON	:表示是自动事务
		* OFF	:表示非自动事务
	# 关闭自动提交
		set autocommit = off;
		* 值为0也可以,因为0代表 false
	# 关闭之后,每次操作都需要执行commit命令
	# 通常都会使用自动事务,当需要使用到事务的时候,我们都是采取临时的事务
	# 该操作,仅仅是对当前连接/线程有效
	# 如果需要彻底修改,那么需要去修改配置文件

-----------------------
事务特性				|
-----------------------
	事务的四大特效:
	# A-Atomic		原子性
		* 一组事务,要么全部提交成功,要么全部失败

	# C-Con...		一致性
		* 事务操作的前后,数据表中的数据.没有变化

	# I-Isol..		隔离性
		* 事务的操作是相互隔离,不受影响的

	#D-D...			持久性
		* 事务一旦提交,就必须要保存到数据库,永久的改变数据表
	
-----------------------
锁机制					|
-----------------------
	# 因为事务的'隔离性质',所以在多线程的时候,MYSQL会有一个锁机制来保证数据的安全
	# INNODB引擎默认的锁机制是:行级锁
	# 但是如果在事务操作的过程中,没有使用到索引(就是说WHERE条件没有使用到主键).那么系统会自动全表检索数据,那么就会自动升级为表锁
	# 行锁:只有当前行被锁定,别的线程不能进行操作
		* 一个线程开启了事务,进行了事务操作之后(使用到了索引,就会单单锁定该行记录)
		* 另外的线程对该条记录进行增/删/该.会被线程阻塞.直到当前事务提交或者回滚

	# 表锁:只有当前表被锁定,别的线程不能进行操作
		* 一个线程开启了事务,进行了事务操作之后(如果操作没有使用到索引,直接锁整张表),
		* 另外的线程对该表进行增/删/改.会被线程阻塞.直到当前事务提交或者回滚
	
-----------------------
事务的隔离级别			|
-----------------------
	# 并发读问题
		* 脏读		:读到另一个事务未提交的数据
		* 不可重复读	:两次读取不一致
		* 幻读(虚读)	:读取到另一个事务已经提交的数据
	
		
	# 四大隔离级别
		* 是用来防止上面三种读问题
		* 4个等级的事物隔离级别,在相同的输入,执行相同的工作,根据不同的隔离级别,可以导致不同的结果。不同的事务隔离级别能够解决数据并发问题的能力是不同的.
		1,Serializable(串行化)(坚决不用)
			* 不会出现任何问题,因为它对同一数据的访问是串行的,并非并发访问的！
			* 性能最差(能处理任何问题)
		2,Repeatable read(可重复读取)(MYSQL默认)
			* 防止脏读和不可重复读,不能处理幻读问题
			* 性能比 Serializable 好
		3,Read Committed(读已提交数据)(Oracle默认)
			* 防止脏读和不可重复读,没有处理不可重复读,也没处理幻读
			* 性能别 Serializable 好
		4,Read Uncommitted 读未提交数据(坚决不用)
			* 可以出现任何事务并发问题,没有处理任何问题.隔离级别最烂
			* 性能最好
	
	# 并发更新问题

	#　查看数据库的隔离级别
		select @@tx_isolation   
		* MYSQL的默认隔离级别(一般没有必要去修改)
		+-----------------+
		| @@tx_isolation  |
		+-----------------+
		| REPEATABLE-READ |
		+-----------------+

	# 修改数据库的隔离级别
		settransaction isolationlevel [四个隔离级别选一个]

	# JDBC设置隔离级别
		Connection conn
		conn.setTransactionlsolation(int leve);
		参数可选值如下
		Connection.TRANSACTION_READ_UNCOMMITTED
		Connection.TRANSACTION_READ_COMMITTED
		... ... 静态变量,字段参阅API

-----------------------
JDBC操作事务			|
-----------------------
	try{
		conn.setAutoCommit(false);//开启事物
		... 
		...
		...
		conn.commit();//try语句的最后提交事务
	}catch(Exception e){
		conn.rollback();//回滚事务
	}










