--------------------------------
RocketMQ-事务消费				|
--------------------------------
	# 分布式事务消费
	# TransactionProducer
	# 支持事务方式对消息进行提交处理,在RocketMQ里事务分为两个阶段
		1,消息传递到Broker,但是.并不会暴露给消费者.
		2,本地消息回调处理,如果成功的话返回 COMMIT_MESSAGE,则通知broker消费消息,如果失败,则 ROLLBACK_MESSAGE,消费者无法消费该消息

--------------------------------
RocketMQ-消息队列避免分布式事务|
--------------------------------
	# 其实,仔细观察生活.已经给出了不少的提示
	# 去餐厅吃饭,付款后会拿到一张小票.只要是小票在,你就会得到食物
	# 经典案例,转账.当账户A成功的扣除了100块的时候,我们给它一个凭据.凭借这个凭据就可以去账户B添加100块
	# 凭借消息(凭证)来完成保证消息的一致性
	# 保存凭证(消息),有两种方案
		1,业务与消息耦合
			* 支付宝在完成扣款的同时,保存消息数据.消息数据月业务数据保存在同一个数据库实例中
			* 伪代码
				事务开始			begin transaction
				支付宝账户扣款		update
				扣款消息保存		insert
				事务提交			commit
			* 只要是支付宝扣了钱,那么消息就一定会被保存下来
			* 只要事务提交,那么就可以通过消息服务,通知余额宝,余额宝处理成功后,发送处理成功消息.支付宝收到消息后.删除该数据
		
		2,业务月消息解耦的方式
			* 支付宝在扣款事务提交之前,给broker发送消息.broker只是记录消息,并不发送.只有消息发送成功才会提交事务
			* 当支付宝扣款事务提交之后,给broker发送确定消息,broker收到消息后,把存储的消息发送给消费者
			* 当支付卡扣款事务回滚之后,不会给broker发送消息,broker更不会把消息推送给消费者
			* 对于那些保存在broker的消息(未确定),需要有一个任务调度,定时的去支付宝系统查询这个消息的状态.并且更新.
				'假设在支付宝扣款事务被成功提交后,系统挂了.此时broker中的消息没有收到事务提交消息,就会导致消息不会被消费'
			* 优点:消息数据独立存储,降低业务系统与消息系统之间的耦合
			* 缺点:一次消息发送,需要两次请求,业务处理服务需要实现消息状态会查接口
			* 伪代码
				//1,把(支付宝 - 100)封装为一个消息
				//2,把这个消息发送到Broker  
				//3,消息成功的到达Broker后会触发一个回调函数(callback)
				//4,在回调函数中完成业务 (支付包 - 100 / update)
				//5,本地事务操作成功,返回 COMMNIT ,告诉broker,可以把封装的消息提交给消费者了
				//6,本地事务操作失败,返回 ROLLBACK,告诉broker,这里回滚了.千万别把消息发送给消费者
			
			* 大事务变成N多个小事务,异步的去执行

--------------------------------
RocketMQ-Producer三种返回值		|
--------------------------------
	COMMNIT
		* 本地事务执行OK,执行消息提交

	ROLLBACK
		* 本地事务回滚,执行消息回滚

	UNKNOW
		* 本地事务执行OK,但是不执行消息提交

--------------------------------
RocketMQ-两阶段提交协议			|
--------------------------------
	# 两阶段提交协议(Two-phase Commnit,2PC)经常被用来实现分布式事务
	# 一般分为协调器C和N多事务执行者(DB)Si两种角色,这里的事务执行者就是具体的数据库.协调器可以和事务执行者在一台机器上
	# 两阶段提交涉及多次节点间的网络通信,通信时间太长
	# 事务时间相对变长,锁定资源的时间也变长了,造成资源等待时间增加
	# 正是由于分布式事务存在很严重的性能问题,大部分高并发的服务都在避免使用,往往通过其他途径来解决数据一致性的问题

