----------------------------
RocketMQ-Linux环境搭建		|
----------------------------
	# 下载地址
		https://github.com/alibaba/RocketMQ/releases
	



--------------------------------------
RocketMQ-单Master模式				  |
--------------------------------------
	# 很显然就是一个机器,除了简单没啥优点.一旦宕机就宕机

--------------------------------------
RocketMQ-多Master模式				  |
--------------------------------------
	# 一般的应用,完全足矣.只要不是淘宝,天猫那种
	# 一个集群,全是MASTER
	# 优点
		* 配置简单，单个Master 宕机或重启维护对应用无影响
		* 在磁盘配置为RAID10 时，即使机器宕机不可恢复情况下，由与 RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）
		* 性能最高

	# 缺点
		* 单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不能被消费，消息实时性会受到受到影响。
	
	# 搭建步骤
		1,修改./conf/2m-noslave/broker-x.properties 配置文件
			* 集群中的所有 brokerClusterName 都是相同的
			* 集群中所有的 brokerName 都'不能相同'
			* 集群中所有的 brokerId 都应该是 0
			* namesrvAddr 配置进去集群中的所有节点的 nameserv 信息
		2,启动,指定配置文件
			nohup ./mqbroker -c ../conf/2m-noslave/broker-x.properties &
			

	# 重点
		1,集群中的所有 brokerClusterName 都是相同的
		2,集群中所有的 brokerName 都不能相同
		3,集群中所有的 brokerId 都应该是 0
		4,namesrvAddr 要配置进去集群中的所有 nameserv 信息
		
	

--------------------------------------
RocketMQ-多Master模式多slave-异步复制|
--------------------------------------
	# 并发确实达到了一定的规模,就是很大很大.数十万,就可以这个
	# 每个Master都配置一个Salve,整个架构有多对 Master-slave,HA才用异步复制,主备有短暂的消息延迟,毫秒级
	# 优点
		* 即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为Master 宕机后，消费者仍然可以从 Slave消费
		* 此过程对应用透明。不需要人工干预。性能同多 Master 模式几乎一样
	# 缺点
		* Master 宕机，磁盘损坏情况，会丢失少量消息
	
	# 搭建步骤

	# 启动顺序
		1,NameServer启动
		2,Master 1 启动
		3,Master x 启动
		4,slave	 1 启动
		5,slave  x 启动
	
	# 重点
		1,只要是集群中的一员,不论主从, brokerClusterName 都是一样的
		2,从节点的 brokerName 和主节点的 brokerNam 一致(而主节点的 brokerName 在整个集群中必须唯一)
		3,主节点的 brokerId 必须为0,从节点的 brokerId ,必须大于0
		4,主节点的 brokerRole 可以是同步双写,或者异步复制,从节点的 brokerRole 必须是 SLAVE

--------------------------------------
RocketMQ-多Master模式多slave-同步双写|
--------------------------------------
	# 并发确实达到了一定的规模,就是很大很大.数十万,就可以这个
	# 每个 Master 配置一个 Slave，整个架构有多对Master-Slave， HA采用同步双写方式，主备都写成功，向应用返回成功。
	# 优点
		数据与服务都无单点， Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高
	# 缺点
		性能比异步复制模式略低，大约低 10%左右，发送单个消息的 RT会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能
	
	# 启动顺序
		1,NameServer启动
		2,Master 1 启动
		3,Master x 启动
		4,slave	 1 启动
		5,slave  x 启动
		
	# 重点
		1,只要是集群中的一员,不论主从, brokerClusterName 都是一样的
		2,从节点的 brokerName 和主节点的 brokerNam 一致(而主节点的 brokerName 在整个集群中必须唯一)
		3,主节点的 brokerId 必须为0,从节点的 brokerId ,必须大于0
		4,主节点的 brokerRole 可以是同步双写,或者异步复制,从节点的 brokerRole 必须是 SLAVE

--------------------------------------
RocketMQ-集群模式总结				  |
--------------------------------------
	1,多MASTER模式
		* 推荐,性能最好
		* 如果有节点宕机有可能会丢失消息(异步刷盘也许会丢,同步刷盘不丢)
	
	2,多MASTER多SLAVE(异步复制)
		* 性能较好
		* 可以保证实时消费
		* 异步复制,也许会丢失消息
		* 客户端只需要把消息发送到MASTER,由MASTER启动线程同步数据到SLAVE

	3,多MASTER多SLAVE(同步双写)
		* 性能比上面个要差点点
		* 可以保证实时消费
		* 同步双写,不会丢失消息
		* 客户端需要把消息发送到MASTER和SLAVE,主从都收到后,才算是发送成功
		