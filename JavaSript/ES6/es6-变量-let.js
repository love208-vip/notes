----------------------------
let							|
----------------------------
	# 块儿级变量声明
		for(var x = 0;x < 5 ; x++){}
		out(x);		//5

		for(let x = 0;x < 5 ; x++){}
		out(x);		//Uncaught ReferenceError: x is not defined

		for (let i = 0; i < 3; i++) {	
			//循环体中的i和判断体中的i在不同的作用域
			let i = 'abc';
			console.log(i);			//输出三次abc
		}
	# 对于函数中的变量提升
		* 不存在变量提升
		* 当函数体内部存在与外部同名的变量,则外部变量没有效(与外部变量脱离关系)
		* 必须在函数最顶部进行声明
		* let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。
		function test(){
			out(x);
			var x = 8;
		}
		test();			//undefined,因为 x 被变量提升到了顶部声明,只是没有赋值

		function test(){
			out(x);
			let x = 8;	//x 并没有被提升到顶部,所以未声明异常
		}
		test();			//Uncaught ReferenceError: x is not defined
	
	# 暂时性死区
		* 只要块级作用域内存在let命令，它所声明的变量就"绑定"(binding)这个区域，不再受外部的影响。
		* "暂时性死区",也意味着 typeof 不再是一个百分之百安全的操作。
			* 如果一个变量根本没有被声明，使用 typeof 反而不会报错
			* 在let变量声明之前使用 typeof 会抛出异常
		* 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
	
	# 不允许重复声明
		* let不允许在相同作用域内，重复声明同一个变量。
	
	# ES6 的块级作用域
		* 可以允许无限重叠
		{{{{
			let x = 5;
		}}}}
	
	# 可以替代匿名自调用函数
		* 匿名自调用函数
			(function(){
				var temp = 15;
			})();
		* let
			{
				let temp;
			}
	
	# ES6 的块级作用域
		* ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
			if (true) {
			  function f() {}			//非法函数定义
			}

			try {
			  function f() {}			//非法函数定义
			} catch(e) {
			}
		* 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。
		* ES6 允许函数在块级作用域中声明
		* ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用.
	
	# do 表达式
		* 本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。
			{
			  let t = f();
			  t = t * t + 1;
			}
			//在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。
		* 现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。
			let x = do {
			  let t = f();
			  t * t + 1;
			};
			//上面代码中，变量x会得到整个块级作用域的返回值。
	
	# 顶层对象的属性
		* 传统的 var 声明,其实就是 window 对象的一个属性
		* 而现在 let 的声明,不再是 window 对象的属性