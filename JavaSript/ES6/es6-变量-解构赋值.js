------------------------------------
解构赋值							|
------------------------------------
	# 一种赋值的语法而已
		let [a,b,c] = [1,2,3];
	#　如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。
		* 以下都会报错
			let [foo] = 1;
			let [foo] = false;
			let [foo] = NaN;
			let [foo] = undefined;
			let [foo] = null;
			let [foo] = {};
	# 这种写法属于 "模式匹配"，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

	# 复杂的案例
		* 多维数组嵌套
			let [foo, [[bar], baz]] = [1, [[2], 3]];
				foo // 1
				bar // 2
				baz // 3

		* 使用空元素占位
			let [ , , third] = ["foo", "bar", "baz"];
				third // "baz"

			let [x, , y] = [1, 2, 3];
				x // 1
				y // 3
		* 对数组进行解构赋值
			* 数组解构失败,会是空数组
			* 却数组只能在最后出现,前面的都匹配完毕后,剩余的所有数据都会被匹配进数组
			let [head, ...tail] = [1, 2, 3, 4];
				head // 1
				tail // [2, 3, 4]

			let [x, y, ...z] = ['a'];
				x // "a"
				y // undefined
				z // []
	
	# 如果解构不成功，变量的值就等于undefined。
		* 以下两种情况都属于解构不成功，foo的值都会等于undefined。
			let [foo] = [];
			let [bar, foo] = [1];