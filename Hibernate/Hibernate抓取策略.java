
――――――――――――――――――――――――――――
一,Hiernate抓取策略			|
――――――――――――――――――――――――――――
	抓取策略,其实也叫做检索策略,是提升性能的一种机制
	
	首先来,区分,延迟和立即检索
		立即检索:当执行某行代码的时候,就会马上发送SQL语句进行查询
		延迟检索:当执行某行代码的时候,不会马上发出SQL语句进行查询,而是当真正使用数据的时候,才会发送SQL进行查询

	最为明显的就是:get/load方法.千万别忘记!

	在映射文件中,class 标签的一个属性可以影响到这个延迟的效果!
	* lazy="true"		--> 延迟检索(默认值)
	* lazy="false"		--> 立即检索,如果是false,那么延迟检索就会失效.就算是load,也会立即查询数据!

	['注意']
		延迟检索(load),需要两个东西!javaBean不能是 final 修饰的,以及映射文件中的 lazy="true"!缺一不可
	
―――――――――――――――――――――――――――――
二,初始化延迟加载的代理对象|
―――――――――――――――――――――――――――――
	* 怎么去理解这个东西呢?
	* 因为延迟加载返回来的就是一个'代理对象'!这个对象,有可能没有被初始化,也就是说并没有查询数据库!没有属性,只有一个OID,当你真正使用它的数据的时候,它才会发生SQL去查询数据库
	* 所以,这里准备了一个方法.用来判断,你的这个代理对象,是不是初始化了的!

	Hibernate.isInitialized(proxy);	//返回一个boolean.初始化了返回true,没有初始化返回false

	如果要对代理对象进行初始化(就是查询数据库赋值),有两个办法
	1,直接使用它的属性,那么会默认的去数据库查询赋值 
	2,调用方法 Hibernate.initialize(proxy); ,就会对指定的代理对象进行初始化!鸡肋...呵呵!

――――――――――――――――――――――――――――
三,类级别与关联级别的检索	|
――――――――――――――――――――――――――――
	类级别的检索:就是你直接查询的那个对象:session.get(XXX.class,"1111");
	关联级别检索:就是你这个对象里面对象,也许是类成员.也许是类成员集合中的对象!
	* 当你检索一个对象的时候,你是不是希望同时的也把改对象中包含的对象一并的检索出来!

	> 查询某个对象的时候,是否需要查询关联对象?
	> 查询关联对象的时候,是否要采用延迟检索?


	类级别的检索
		> 在映射文件 class 的标签上配置:lazy 属性
	关联级别检索
		> 在映射文件,关系映射的 <Set>,或者是 <Many-to-one>的标签上进行配置
		* lazy="true" [默认]
			> 当查询主对象的时候,不会先查询该从对象
			* 查询客户的时候,不会立即加它的订单到集合中,当真正使用的时候,才会去数据库中查找
		* lazy="false"
			> 当查询主对象的时候,会立即的把从对象也查出来
			* 查询客户的时候,会立即加载它的订单对象到客户对象的集合当中
		
	<Set>
		* fetch:控制SQL语句的类型
			* join			
				* 如果 fetch的属性是join,那么lazy的属性会被无视!设啥都一样!
				* 发送迫切左外连接的SQL查询关联对象,说白了就是,不管laze属性,都会查出关联数据封装对象.
			* select
				* 默认值,发送多条SQL去查询.第一条查询Customer,第二条查询Order
			* subselect
				* 发送子查询,去查询关联对象!
		* lazy:控制关联对象的检索是否采用延迟
			* true
				* 在查询关联对象的时候,使用延迟检索
			* false
				* 在查询关联对象的时候,不使用延迟检索
			* extra
				* 极其懒惰:在你正儿八经的使用到关联对象的属性的时候才会去加载!
				> 如果你只是查询集合中有多少个对象!那么它只会发送一个统计的SQL,count();不会去加载!
	
	<many-to-one>
		* 该元素也有lzy,和fetch属性,但是有些不一样
		* fetch:控制SQL语句的发送格式
			* join
				* 发生一个迫切做外连接去查询关联对象,
				* 如果配置了join,那么lazy属性会被忽略
			* select
				* 发送多条SQL去检索关联对象
		* lazy :关联对象检索的时候,是否采用延迟
			* false
				* 不延迟
			* proxy
				* 交给 管理对象配置文件的 class 属性上的lazy来决定,我不管了
			* no-porxy
				* 不使用代理

――――――――――――――――――――――――――――
四,批量抓取					|
――――――――――――――――――――――――――――
	* 所谓的批量抓取就是在<set>标签上的一个属性: batch-size="3"
	* 该属性,仅仅存在于<set>标签,属性值指定一次抓取多少条记录.

	
	

	这个抓取策略没学好... ...
