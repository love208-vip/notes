――――――――――――――――――――――――――――
一,一对多的映射	(最重要)	|
――――――――――――――――――――――――――――
一
		* 就是有集合的一方(客户)
		<!-- 一对多映射 
			name  :集合属性名
			column:集合中的对象,对应的表!指向我们主键的外键名称
			class :集合内对象的Class
			cascade:级联操作
		-->
		<set name="orders"  cascade="all">
			<key column="cid"/>
			<one-to-many class="com.kevin.domain.Order"/>
		</set>
多	
		* 就是只有引用的一方(订单)
		<!--  多对一映射
		name :本类中的属性名,也就是关联其他对象的属性名
		colum:在本类对应表中,外键的名称
		class:关联的对象的,Class地址
		 -->
		<many-to-one name="customer" class="com.kevin.domain.Customer" column="cid"/>

[关于级联]
	1,当持久化状态的对象中,持有了临时状态的对象的时候.插入持久化状态会报错(一对多关系中,不能只保存一方)
		* sesssion.save(obj);中obj含有了一个新new出来,但是没有跟session建立关系的对象!
	2,解决上述问题的办法(一对多关系中,可以只保存一方)
		* 设置级别操作:一般级联都是设置在,被引用的一方(客户与订单,那么就在客户上进行设置)!保存客户的时候,就算客户对象里面的订单对象是临时状态.也能插入!
	['总结']
	想要保存订单对象,自动保存订单中的客户对象
		* 在订单配置中,设置级联
	想要保存客户对象,自动保存客户中的订单对象
		* 在客户配置中,设置级联
	* 你在哪个对象的配置上设置了级联,那么在保存这个对象的时候,就可以自动保存这个对象中包含/引用的对象!

[关于表维护]
	* 哪个表适合有维护能力?	-- "自己的主键被别人的外键引用了"
	如果没有维护表能力,会删除失败!因为别人还引用着我!设置表能力后,可以进一步的设置一些级联操作.我被弄死之后,引用我的记录是设置null,还是删除!

	如果双发都有表维护权利,那么就会产生多余的SQL语句
	* 此时我们就需要让一方去放弃自动维护权
	* 一般都是由多的一方来维护的!也就是多的一方:inverse="true",但也有特殊情况,要根据实际的需求来定!
		 > 放弃维护权,那么就不能对关联表进行其他的操作了.

[孤儿删除]
	* 只能应用于一对多的情况下!一为父,多为子!当父亲被删!那么子的引用为null,直接删除掉子!

	
cascade:操作对象
inverse:关联主键
	['demo']
	客户配置:cascade=""save-update" inverse="true"			//有级联操作,可以存入临时状态的订单对象,但是放弃了表维护权利
	* 对客户进行保存操作就是:客户,订单都能成功的存入!但是,订单的引用为null,因为客户不具备比维护权利!
――――――――――――――――――――――――――――
二,旧笔记					|
――――――――――――――――――――――――――――
	关联关系
	一对多
		> 一个教师,带有几个班级
	多对一
		> 一个班的学生,只有一个班主任

【外键,在多的一方】【外键,在多的一方】【外键,在多的一方】

集合元素是普通数据类型,我们已经学过了,会操作了.现在就得学学,
集合元素里面,是另一个实体类
--------------------------------------------------------------------------------
多对一
	> 外键列
	> 关联的是什么类型
<!-- 雇员表映射文件 -->
<hibernate-mapping package="com.kevin.domain">
    <class name="Employee" table="employee">
        <id name="id" type="string" column="eid" length="32">
            <generator class="assigned"/>
        </id>
        <property name="name" type="string" column="name" length="20"/>
        <!--该标签表达的是,跟另一个类的关系,就是说啊,我这是个外键,多对一(标签名很实在啊对不对?)
        	many-to-one:在javaBean中表示另一个引用形成员变量,在SQL中表示这是一个外键...
        		> name:就是javaBean的字段名称,你的引用形属性名
        		> class:很显然,就是你引用型成员属性的类类型
        			* 尽量写带包全路径,如果你的根标签带有package,而且这个类就在指定包下,可以直接写简单类名
        		> column:该属性值就是外键的名称
        			* 如果不写,那么默认的就name属性的值,也就是说框架默认,我们的SQL外键名称,跟我们的引用的javaBean属性名一样
        		> property-ref:引用其他属性,其实就是引用非外键的列(你见过外键引用的是别人的非主键?)
        			* 千万别用,这个是设计上的一大败笔
        		> update:进行update操作时是否包含此字段 
        		> insert:进行insert操作时是否包含此字段
         -->
         <many-to-one name="department" class="com.kevin.domain.Department" column="aaaa">
         	
         </many-to-one>
    </class>
</hibernate-mapping>
--------------------------------------------------------------------------------
一对多
	> 集合表(一对多里面,就是有个集合容器,能装其他的对象)
	> 集合元素
	> 集合外键(引用了我主键的那些关联的实体类型... ...)
<!-- 部门表映射文件 -->
<hibernate-mapping package="com.kevin.domain">
    <class name="Department" table="department">
        <id name="id" type="string" column="did" length="32">
            <generator class="assigned"/>
        </id>
        <property name="name" type="string" column="name" length="20"/>
        <!--Set集合,该集合里面是对象,不是基本数据类型,代表本类与另一个类的关系,一对多
        	set:这个标签,就是在本类中有一对多关系,有一个容器
        		> name:本类容器属性的名称
        		> table:容器里面装的元素从哪张表获取?多此一举的标签
        		* 通过下面的class属性就能找到映射文件,也就能找到table名称,就算你乱写,也是会被框架忽略
        		> inverse:默认为false,如果为true,表示由对方维护关联关系
        			> 跟关联表之间的一个维护true,就是我不维护,false就是我也会维护
        			* 一般这个东西都是设置在被引用的表上,没有外键,设置为true,让引用我们主键的表自己去维护
        			* 一般有外键,就是引用了别人的表的表,一般都没办法放弃"主动维护"的,都得自己来,都没那个关键字
        			* 谁不主动维护,谁就是生活不能自理!自己不会管理任何引用的问题！
        		> cascade:级联(默认,为none代表没有任何级联操作)
        			> delete:就是当我对自己表中的数据,进行删除/修改的时候.引用了自己表主键的那些数据是跟着删除还是?
        				* 操作主对象的时候,关联对象也做相同的操作
					> delete-orphan:孤儿删除(孤子删除),仅限于一对多!
						* 只有一对多的时候,只有父子表存在.一的一方,为父.多的一方为子!
						* 当父亲与子,解除了关系!也就是子的外键置为了null,那么子会自动删除
					> all-delete-orphan:包含了孤儿删除的所有级联
        			> save-update:主对象被修改的时候,从对象也做修改
        			> all:代表所有操作,除了孤儿删除(删除,更改都需要从对象跟随主对象的话,就用这个all)
        			> none:没有任何级联操作(主对象被删除,那么从对象的引用为null)
        				* 可以写多个,之间用,号隔开:cascade="save-update,all"
        				* !!!这东西一般是,多对一的时候,也就是:部门-员工.这种情况才使用！删除部门员工就都删除,不可能是删除一个员工,就整个部门都没!虽然这样在JAVA代码上是没问题的,但是不符合逻辑
				> order-by:排序,因为Set集合是无序的,每次取出的数据顺序也许都不一样!如果我们需要顺序的话.可以通过这个进行排序
					> 
        	key:对方类,对方类的哪个字段?引用了我们的主键
        		> column:就是对方表,引用了我们主键的字段,也就是外键
         -->
         <set name="employees" inverse="false" cascade="none">
         	<key column="aaaa"/>
         	<one-to-many class="com.kevin.domain.Employee"/>
         </set>
    </class>
</hibernate-mapping>
--------------------------------------------------一些建议
1,被依赖的表,也就是没有外键!只是被其他表所引用的表.尽量的先插入(如果后插入的话,前面引用表插入数据后没找到数据,就会等待后面的插入,然后再使用update语句进行修改插入,比较浪费SQL服务器资源)!而且inverse="true"设置为true,不让它自己去维护表!
2,维护对象关系,就是设置外键列的值!这个东西只会影响插入,修改!不会影响查询！查询还是会去别人的表找对应的数据,只是插入的时候,不会去别人的表插入自己的数据!
	> 自私,拿出来的时候会找人要,修改/放进去的时候不理别人！
	> 自己起床要把朋友叫起来,自己睡的时候就不管别人了！说好要一起睡一起醒的!
	...我实在是找不到通俗的比喻了！
	> 这个东西会影响到解除对象关系.
inverse--------------------------------------------------
inverse="false"
首先这个属性为false,的时候,表示这个表会去维护关系
	当这个表的数据被删除,它会先把引用它的表的列(外键),设置为null之后,再删除自己
inverse="true"(此时,这个表不会自动的维护关系)
	* 两种情况
> 没有关联的数据
	* 直接删除,没问题,因为没人引用！而且又不用维护属性
> 有关联的数据
	* 由于不能维护对象关系,别人又引用了这条数据,你在删除的时候就出抛出异常
	> 不能删除的更新,因为外键约束!

cascade--------------------------------------------------
	这东西就只适合在一对多的情况下使用!
	级联,我怎么样,引用我的那些,也得怎么样！

所谓的单项关联
	> 就是在部门对象中,没有员工这个集合存在!而员工对象中,有部门对象存在.!




头部DTD文件
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
