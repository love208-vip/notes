----------------------------
Dubbo-分布式服务子系统划分	|
----------------------------
	# 不要出现A服务中的SQL需要连接查询到B服务中的表等情况,这样A服务在与B服务进行垂直拆库时就会出错

	# 服务子系统间避免出现环状的依赖调用
		A服务 依赖 B服务
		B服务 依赖 C服务
		C服务 依赖 A服务

	# 服务子系统间的依赖关系链不要过长
		

	# 尽量避免分布式事务
	
	# 子系统的划分,其实是一个不断优化的过程

----------------------------
Dubbo-接口的设计原则		|
----------------------------
	# 设计方式
		action		->	控制层
		facade		->	服务接口
		biz			->	业务逻辑
		dao			->	持久层

		好的Dubbo服务接口设计,并非只是纯粹的接口服务化
	
	# 接口类型
		简单数据查询接口			:action,facade,dao
		带业务逻辑的数据查询接口	:action,facade,biz,dao

		简单的数据写入接口			:action,facade,dao
		带业务逻辑的数据写入接口	:action,facade,biz,dao

		同步接口
		异步接口

	
	# 设计原则
		1,接口粒度
			* 服务接口尽可能大粒度,每个服务方法应该代表一个功能,而不是某功能的一个步骤,否则将面临分布式事务的问题.
			* Dubbo并未提供分布式事务支持,同时可以减少系统之间的网络交互
			* 服务接口建议以业务场景为单位划分,并对相近业务做抽象,防止接口数量爆炸
			* 不建议使用过于抽象的通用接口,如 : Map query(Map map); 这样的接口没有明确语意,会给后带来不便
		
		2,接口版本
			* 每个接口,都应该设置一个版本.为后续不断升级提供可能
			* 	<dubbo:service version="1.0"/>
		
		3,接口兼容性
			* 服务接口增加方法,或者服务模型(DTO),增加字段,应该向后兼容
			* 删除方法或者删除字段,将不兼容,枚举类型新增字段也不兼容,需要通过变更版本号升级
		
		4,异常处理
			* 建议使用异常回报错误,而不是返回错误代码,异常信息能携带更多信息,以及语意更友好
			* 如果担心性能问题,在必要时,可以通过覆写调用异常类的 fillInStackTrace();方法,做空实现,使其不拷贝栈信息
			* 查询方法,不建议抛出 checked 异常,否则调用方法在查询时,将会有过多的 try..catch,并且不能进行有效的处理
			* 服务提供方,不应该把DAO或者SQL等异常抛给消费方,应该在服务实现中对消费方不关心的异常,进行包装.否则可能出现消费方无法反序列化相应异常

		5,必要的参数校验
			
		6,在Provider上尽量多配置Consumer端属性
			* 作为服务的提供者,比服务使用方,更清楚服务性能参数.如:调用超时时间,合理的重试次数等等
			* 在Provider上配置后,Consumer不配置,会使用Provider的配置值,也就是使用Provider的配置作为Consumer的缺省值,否则Cusomter会使用Consumer端的全局配置,这对于Provider不可控,并且往往是不合理的
			* Provider上尽量多配置Consumer端的属性,让Provider实现者,一开始就思考Provider服务特点,服务质量问题
			* '消费者的配置优先,尽量在服务提供者'
		
		
----------------------------
Dubbo-总结					|
----------------------------
	服务接口设计,与服务子系统划分过程相互优化
	
